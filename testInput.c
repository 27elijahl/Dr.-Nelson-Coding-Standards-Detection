
/**
 * Elijah L
 * Created 2025-10-06
 * Manages user configuration for an n-layer neural network, with
 * optimizing features which are on occasion collectively referred to
 * by the title "backpropagation". This file solely manages selecting 
 * options as specified in the functions getUserInput and the functions 
 * that it calls. These files are then referenced externally in run.c, 
 * where functions such as run() and train() are called from this class.
 *
 * Configuration of the program is stored externally in a local binary
 * file called "cf," which can be generated by a parser from a
 * human-readable format. Additionally, there is also a parser for
 * creating the truth table and test cases binary file from human 
 * input, the names of which are available as config variables.
 *
 * Unless documented otherwise, all functions in main.c and run.c whose
 * return type is an int return 0 in the case of success and -1 in the
 * case of failure.
 *
 * This file uses a table library in the lib directory for proper
 * formatting.
 *
 * ====================================================================
 * main.c
 * double identityActivationFunction(double input)
 * double identityActivationFunction_prime(double input)
 * double sigmoidActivationFunction(double input)
 * double sigmoidActivationFunction_prime(double input)
 * double hyperbolicTangentActivationFunction(double input)
 * double hyperbolicTangentActivationFunction_prime(double input)
 * void truthXor(double* input, double* output)
 * void truthOr(double* input, double* output)
 * void truthAnd(double* input, double* output)
 * void truthAndOrXor(double* input, double* output)
 * void truthXorAndOrXor(double* input, double* output)
 * void getUserInput()
 * int getUserInputFromFile()
 * int validateUserInput()
 * void outputUserInput()
 * int main(int argc, char** argv)
 *
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>

#include "../include/run.h"
#include "../include/constants.h"


char* configFileName = CONFIG_FILE_NAME;

int activationLayers = 0;   // equivalent to the length of the lengths array
int* lengths;               // the lengths (number of activations) of each layer

int testCaseLength = 0; // how many test cases are there

double (*activationFunction)(double input) = NULL;      // a function pointer to the activation function
double (*activationFunctionPrime)(double input) = NULL; // a function pointer to the derivative of the activation function


bool training = false;                // true when the mode is training, and false when the mode is running
bool runningTestCases = false;        // true when individually testing each of the test cases
bool randomWeightPropagation = false; // true when initial weights are set randomly, and false when set manually


void (*truthFunction)(double* input, double* output) = NULL; // specifies which function is used to determine T, the truth value

/**
 * RANDOM WEIGHTS CONFIGURATION
 */
double randomUpperBound = 0.0; // maximum value of the random input for randomizing initial weights during training and running
double randomLowerBound = 0.0; // minimum ""


/**
 * TRAINING CONFIGS
 */
int maxIterations = 0;           // the maximum of iterations during training
double maxAcceptableError = 0.0; // the error at which training will be declared successful
double λ = 0.0;                  // the value of λ, defining the step size
bool printInputTable = false;    // whether to print the input table after training
bool printTruthTable = false;    // whether to print the truth table after training
bool outputNetworkInfo = false;  // whether to print network info including weights

/**
 * the number of training iterations between which the current error
 * will be printed, to ensure the continued progress of the training.
 */
int keepAlive = 0;

/**
 * if not 0, what the column size of the transposition of the training cases should be for output
 */
int reordering = 0;


/**
 * WEIGHT FILE READING
 */
bool loadFile = false;                  // whether to load weights from a file
char loadFileName[MAX_FILE_NAME_SIZE];  // the name of the file to read

bool saveFile = false;                  // whether to save weights after training to a file
char saveFileName[MAX_FILE_NAME_SIZE];  // the name of the file to which to save weights

/**
 * TEST CASE FILE READING
 */
bool readTestCases = false;                 // whether to read the test cases from a binary file
char testCasesFileName[MAX_FILE_NAME_SIZE]; // the name of the binary file to read

/**
 * TRUTH TABLE FILE READING
 */
bool readTruthTable = false;                    // whether to construct the truth table from a binary file
char truthTableFileName[MAX_FILE_NAME_SIZE];    // the name of the file from which to read the truth table

/**
 * Represents the value stored in the input configuration binary file 
 * to encode the truth function used for generating the truth table 
 * when not read from an input file.
 */
enum truthFunctionEncoding
{
   ENCODING_TRUTH_XOR = 0,
   ENCODING_TRUTH_OR = 1,
   ENCODING_TRUTH_AND = 2,
   ENCODING_TRUTH_AND_OR_XOR = 3,
   ENCODING_TRUTH_XOR_AND_OR_XOR = 4
};

/**
 * Represents the value stored in the input configuration binary file
 * to encode the activation function as well as the activation
 * function's derivative as configuration variables.
 */
enum activationFunctionEncoding
{
   ENCODING_ACTIVATION_IDENTITY = 0,
   ENCODING_ACTIVATION_SIGMOID = 1,
   ENCODING_ACTIVATION_TANH = 2,
   ENCODING_ACTIVATION_RECTIFIED_LINEAR = 3,
};

char networkConfiguration[NETWORK_CONFIGURATION_LENGTH];  // a saved string for the network configuration




/**
 * Refers to the activation function f(x)=x.
 */
double identityActivationFunction(double input)
{
   return input;
}

/**
 * Refers to the derivative of the activation function f(x)=x.
 */
double identityActivationFunction_prime(double input)
{
   return 1.0;
}

/**
 * Refers to the logistic sigmoid 1/(1+e^-x).
 */
double sigmoidActivationFunction(double input)
{
   return 1.0/(1.0 + exp(-1.0 * input));
}

/**
 * Refers to the derivative of the logistic sigmoid activation function.
 */
double sigmoidActivationFunction_prime(double input)
{
   double sigmoidResult = sigmoidActivationFunction(input);
   return sigmoidResult * (1.0 - sigmoidResult);
}

/**
 * Refers to the the hyperbolic tangent activation
 * function.
 */
double hyperbolicTangentActivationFunction(double input)
{
   double εx = ε(input);
   double exponent = exp(εx * 2.0 * input);
   return εx * (exponent - 1.0) / (exponent + 1.0);
}

/**
 * Refers to the derivative of the hyperbolic tangent activation
 * function.
 */
double hyperbolicTangentActivationFunction_prime(double input)
{
   double hyperbolicTangentResult = 
      hyperbolicTangentActivationFunction(input);

   return 1.0 - hyperbolicTangentResult * hyperbolicTangentResult;
}

double rectifiedLinearActivationFunction(double input)
{
   return input > 0 ? input : 0;
}

double rectifiedLinearActivationFunction_prime(double input)
{
   return input > 0;
}

/**
 * Refers to the truth function of arity two and coarity one where the 
 * result, saved to the output array, is the XOR of the first two input 
 * parameters.
 */
void truthXor(double* input, double* output)
{
   output[0] = (double)((bool)input[0] ^ (bool)input[1]);
   return;
}

/**
 * Refers to the truth function of arity two and coarity one where the 
 * result, saved to the output array, is the OR of the first two input 
 * parameters.
 */
void truthOr(double* input, double* output)
{
   output[0] = (double)((bool)input[0] | (bool)input[1]);
   return;
}

/**
 * Refers to the truth function of arity two and coarity one where the 
 * result, saved to the output array, is the AND of the first two input 
 * parameters.
 */
void truthAnd(double* input, double* output)
{
   output[0] = (double)((bool)input[0] & (bool)input[1]);
   return;
}

/**
 * Refers to the truth function of arity two and coarity three where 
 * the result (saved to the output array) is a logical AND of the first 
 * two input parameters for the first index, OR for the second, and XOR 
 * for the third.
 */
void truthAndOrXor(double* input, double* output)
{
   output[0] = (double)((bool)input[0] & (bool)input[1]);
   output[1] = (double)((bool)input[0] | (bool)input[1]);
   output[2] = (double)((bool)input[0] ^ (bool)input[1]);
   return;
}

/**
 * Refers to the truth function of arity three and coarity three where 
 * the result (saved to the output array) is the logical AND of q and
 * the third parameter for the first index, OR for the second, and 
 * XOR for the third, where q represents the logical XOR of the first
 * two parameters.
 */
void truthXorAndOrXor(double* input, double* output)
{
   bool q = (bool)input[0] ^ (bool)input[1];
   output[0] = (double)(q & (bool)input[2]);
   output[1] = (double)(q | (bool)input[2]);
   output[2] = (double)(q ^ (bool)input[2]);
   return;
}


/**
 * Sets generic user-specified configuration variables to values
 * specified manually in the code. This function is not used.
 */
void getUserInput()
{
   training = true;
   runningTestCases = true;
   randomWeightPropagation = true;
   loadFile = false;
   saveFile = false;
   readTestCases = true;
   readTruthTable = true;

   activationLayers = 4;
   lengths = (int*)malloc(activationLayers * sizeof(int));
   lengths[0] = 2;
   lengths[1] = 1;
   lengths[2] = 1;
   lengths[3] = 3;

   testCaseLength = 4;

   activationFunction = &sigmoidActivationFunction;
   activationFunctionPrime = &sigmoidActivationFunction_prime;

   truthFunction = &truthAndOrXor;
      
   outputNetworkInfo = false;
   printInputTable = true;

   if (randomWeightPropagation)
   {
      randomUpperBound = 1.5;
      randomLowerBound = 0.1;
   }

   if (training) 
   {
      maxIterations = 100000;

      maxAcceptableError = 0.0002;

      λ = 0.3;

      printTruthTable = true;

      keepAlive = 0;
      
      reordering = 0;
   }

   if (loadFile)
   {
      strcpy(loadFileName, "we");
   }

   if (saveFile)
   {
      strcpy(saveFileName, "we");
   }
   
   if (readTestCases)
   {
      strcpy(testCasesFileName, "tc");
   }
   
   if (readTruthTable)
   {
      strcpy(truthTableFileName, "tt");
   }
   return;
} // void getUserInput()

/**
 * Gets user-specified configuration variables from the config variable
 * specified by the constant CONFIG_FILE_NAME or the first command line
 * argument, in a binary format.
 */
int getUserInputFromFile()
{
   FILE* file = fopen(configFileName, "rb");

   bool incompleteFileReading = false;

   incompleteFileReading |=
      fread(&training, sizeof(char), 1, file) < 1;
   incompleteFileReading |= 
      fread(&printTruthTable, sizeof(char), 1, file) < 1;
   incompleteFileReading |= 
      fread(&runningTestCases, sizeof(char), 1, file) < 1;
   incompleteFileReading |= 
      fread(&randomWeightPropagation, sizeof(char), 1, file) < 1;
   incompleteFileReading |= 
      fread(&loadFile, sizeof(char), 1, file) < 1;
   incompleteFileReading |= 
      fread(&saveFile, sizeof(char), 1, file) < 1;
   incompleteFileReading |= 
      fread(&readTestCases, sizeof(char), 1, file) < 1;
   incompleteFileReading |= 
      fread(&readTruthTable, sizeof(char), 1, file) < 1;
   incompleteFileReading |= 
      fread(&outputNetworkInfo, sizeof(char), 1, file) < 1;
   incompleteFileReading |= 
      fread(&printInputTable, sizeof(char), 1, file) < 1;

   incompleteFileReading |=
      fread(&maxIterations, sizeof(int), 1, file) < 1;


   incompleteFileReading |=
      fread(&activationLayers, sizeof(int), 1, file) < 1;

   lengths = malloc(activationLayers * sizeof(int));
   for (int it = 0; it < activationLayers; it++)
   {
      incompleteFileReading |=
         fread(&lengths[it], sizeof(int), 1, file) < 1;
   }

   printf("%s\n", incompleteFileReading ? "true" : "false");
   incompleteFileReading |=
      fread(&testCaseLength, sizeof(int), 1, file) < 1;

   incompleteFileReading |=
      fread(&maxAcceptableError, sizeof(double), 1, file) < 1;
   incompleteFileReading |=
      fread(&λ, sizeof(double), 1, file) < 1;
   incompleteFileReading |=
      fread(&randomUpperBound, sizeof(double), 1, file) < 1;
   incompleteFileReading |=
      fread(&randomLowerBound, sizeof(double), 1, file) < 1;

   char buffer[MAX_FILE_NAME_SIZE];
   incompleteFileReading |= 
      fread(buffer, sizeof(char), MAX_FILE_NAME_SIZE, file) 
      < MAX_FILE_NAME_SIZE;
   strcpy(loadFileName, buffer);
   incompleteFileReading |=
      fread(buffer, sizeof(char), MAX_FILE_NAME_SIZE, file)
      < MAX_FILE_NAME_SIZE;
   strcpy(saveFileName, buffer);
   incompleteFileReading |=
      fread(buffer, sizeof(char), MAX_FILE_NAME_SIZE, file)
      < MAX_FILE_NAME_SIZE;
   strcpy(testCasesFileName, buffer);
   incompleteFileReading |=
      fread(buffer, sizeof(char), MAX_FILE_NAME_SIZE, file)
      < MAX_FILE_NAME_SIZE;
   strcpy(truthTableFileName, buffer);

   int truthFunctionValue;
   incompleteFileReading |=
      fread(&truthFunctionValue, sizeof(int), 1, file) < 1;
   switch (truthFunctionValue)
   {
      case ENCODING_TRUTH_XOR: truthFunction = &truthXor; break;
      case ENCODING_TRUTH_OR: truthFunction = &truthOr; break;
      case ENCODING_TRUTH_AND: truthFunction = &truthAnd; break;
      case ENCODING_TRUTH_AND_OR_XOR: truthFunction = &truthAndOrXor; break;
      case ENCODING_TRUTH_XOR_AND_OR_XOR: truthFunction = &truthXorAndOrXor; break;
      default: truthFunction = NULL;
   }

   int activationFunctionValue;
   incompleteFileReading |=
      fread(&activationFunctionValue, sizeof(int), 1, file) < 1;

   switch (activationFunctionValue)
   {
      case ENCODING_ACTIVATION_IDENTITY: 
         activationFunction = &identityActivationFunction;
         activationFunctionPrime = &identityActivationFunction_prime;
         break;
      case ENCODING_ACTIVATION_SIGMOID:
         activationFunction = &sigmoidActivationFunction;
         activationFunctionPrime = &sigmoidActivationFunction_prime;
         break;
      case ENCODING_ACTIVATION_TANH:
         activationFunction = &hyperbolicTangentActivationFunction;
         activationFunctionPrime = &hyperbolicTangentActivationFunction_prime;
         break;
      case ENCODING_ACTIVATION_RECTIFIED_LINEAR:
         activationFunction = &rectifiedLinearActivationFunction;
         activationFunctionPrime = &rectifiedLinearActivationFunction_prime;
         break;
   } // switch (activationFunctionValue)
   
   incompleteFileReading |=
      fread(&keepAlive, sizeof(int), 1, file) < 1;

   incompleteFileReading |=
      fread(&reordering, sizeof(int), 1, file) < 1;

   if (incompleteFileReading)
   {
      printf(ERROR("Config file reading failed"));
   }

   fclose(file);
   return incompleteFileReading ? -1 : 0;
} // void getUserInputFromFile()

/**
 * Ensures that all user-configurable variables are valid and do not
 * contradict, or else returns -1 and prints the error.
 */
int validateUserInput()
{
   int returnValue = 0;

   if (randomWeightPropagation && loadFile)
   {
      printf(ERROR("Cannot both get weights randomly and by a file"));
      returnValue = -1;
   }

   if (loadFile && strlen(loadFileName) == 0)
   {
      printf(ERROR("Invalid load file name"));
      returnValue = -1;
   }

   if (saveFile && strlen(saveFileName) == 0)
   {
      printf(ERROR("Invalid save file name"));
      returnValue = -1;
   }

   if (randomLowerBound > randomUpperBound)
   {
      printf(ERROR("Invalid random upper and lower bounds"));
      returnValue = -1;
   }
   
   if (activationLayers <= 0)
   {
      printf(ERROR("Invalid activation layers count (%d)\n"), activationLayers);
   }

   for (int it = 0; it < activationLayers; it++)
   {
      if (lengths[it] <= 0)
      {
         printf(ERROR("Invalid length value(s) for network configuration %s"),
               networkConfiguration);
         returnValue = -1;
      }
   }
   

   if (activationFunction != &sigmoidActivationFunction &&
       activationFunction != &identityActivationFunction &&
       activationFunction != &hyperbolicTangentActivationFunction &&
       activationFunction != &rectifiedLinearActivationFunction)
   {
      printf(ERROR("Invalid activation function"));
      returnValue = -1;
   }

   if (activationFunctionPrime != &sigmoidActivationFunction_prime &&
       activationFunctionPrime != &identityActivationFunction_prime &&
       activationFunctionPrime != &hyperbolicTangentActivationFunction_prime &&
       activationFunctionPrime != &rectifiedLinearActivationFunction_prime)
   {
      printf(ERROR("Invalid activation function derivative"));
      returnValue = -1;
   }

   if (!readTruthTable)
   {
      if (truthFunction == &truthXor || truthFunction == &truthOr || 
            truthFunction == &truthAnd)
      {
         if (lengths[INPUT_LAYER_INDEX] != 2 || lengths[OUTPUT_LAYER_INDEX] != 1)
         {
            printf(ERROR("Invalid truth function for network "
                     "configuration (requires 2-...-1)"));
            returnValue = -1;
         }
      } 
      else if (truthFunction == &truthAndOrXor)
      {
         if (lengths[INPUT_LAYER_INDEX] != 2 || lengths[OUTPUT_LAYER_INDEX] != 3)
         {
            printf(ERROR("Invalid truth function for network "
                     "configuration (requires 2-...-3)"));
            returnValue = -1;
         }
      }
      else if (truthFunction == &truthXorAndOrXor)
      {
         if (lengths[INPUT_LAYER_INDEX] != 3 || lengths[OUTPUT_LAYER_INDEX] != 3)
         {
            printf(ERROR("Invalid truth function for network "
                     "configuration (requires 3-...-3)"));
            returnValue = -1;
         }
      }
      else
      {
         returnValue = -1;
      }
   }

   if (training)
   {
      if (maxIterations < 0)
      {
         printf(ERROR("Invalid maxIterations value"));
         returnValue = -1;
      }

      if (maxAcceptableError < 0.0)
      {
         printf(ERROR("Invalid maxAcceptableError value"));
         returnValue = -1;
      }

      if (keepAlive < 0)
      {
         printf(ERROR("Invalid keepAlive value"));
         returnValue = -1;
      }
   } // if (training)

   if (reordering < 0)
   {
      printf(ERROR("Invalid reordering value"));
      returnValue = -1;
   }

   return returnValue;
} // int validateUserInput()


/**
 * Echos the value of user-specified generic variables.
 */
void outputUserInput()
{
   printf("training: %s\n"
          "runningTestCases: %s\n"
          "randomWeightPropagation: %s\n"
          "loadFile: %s\nsaveFile: %s\n"
          "readTestCases: %s\nreadTruthTable: %s\n",
          training ?                COLORED_YES : COLORED_NO,
          runningTestCases ?        COLORED_YES : COLORED_NO,
          randomWeightPropagation ? COLORED_YES : COLORED_NO,
          loadFile ?                COLORED_YES : COLORED_NO,
          saveFile ?                COLORED_YES : COLORED_NO,
          readTestCases ?           COLORED_YES : COLORED_NO,
          readTruthTable ?          COLORED_YES : COLORED_NO);

   printf("activationLayers: %d\n", activationLayers);
   
   printf("lengths: [");
   printf("%d", lengths[0]);

   for (int it = 1; it < activationLayers; it++)
   {
      printf(", %d", lengths[it]);
   }

   printf("]\n");

   printf("Network configuration: a %s%s%s network\n", 
         ANSI_BOLD, networkConfiguration, ANSI_CLEAR);

   printf("testCaseLength: %d\n", testCaseLength);

   printf("activationFunction: ");

   if (activationFunction == &identityActivationFunction) 
   {
      printf("f(x) = x");
   }
   else if (activationFunction == &sigmoidActivationFunction)
   {
      printf("sigmoid");
   } 
   else if (activationFunction == &hyperbolicTangentActivationFunction)
   {
      printf("tanh");
   }
   else if (activationFunction == &rectifiedLinearActivationFunction)
   {
      printf("rectified linear");
   }

   printf("\n");
   
   printf("activationFunctionPrime: ");

   if (activationFunctionPrime == &identityActivationFunction_prime)
   {
      printf("prime of [f(x) = x]");
   }
   else if (activationFunctionPrime == 
         &sigmoidActivationFunction_prime)
   {
      printf("prime of sigmoid");
   }
   else if (activationFunctionPrime == 
         &hyperbolicTangentActivationFunction_prime)
   {
      printf("prime of tanh");
   }
   else if (activationFunctionPrime ==
         &rectifiedLinearActivationFunction_prime);

   printf("\n");
 
   printf("reordering: %d\n", reordering);
   
   printf("outputNetworkInfo: %s\n", 
         outputNetworkInfo ? COLORED_YES : COLORED_NO);
   printf("printInputTable: %s\n", 
         printInputTable ? COLORED_YES : COLORED_NO);


   if (!randomWeightPropagation) printf(ANSI_GRAY_TEXT);

   printf("randomUpperBound: %0.4f\n", randomUpperBound);
   printf("randomLowerBound: %0.4f\n", randomLowerBound);

   printf(ANSI_CLEAR_TEXT);


   if (!training) printf(ANSI_GRAY_TEXT);

   printf("maxIterations: %d\n", maxIterations); 

   printf("maxAcceptableError: %lf\n", maxAcceptableError);

   printf("λ: %lf\n", λ);

   if (training)
   {
      printf("printTruthTable: %s\n", 
            printTruthTable ? COLORED_YES : COLORED_NO);
   } 
   else
   {
      printf("printTruthTable: %s\n", 
            printTruthTable ? "yes" : "no");
   }

   printf("truthFunction: ");
   if (truthFunction == &truthAndOrXor)
   {
      printf("and|or|xor");
   }
   else if (truthFunction == &truthAnd) 
   {
      printf("and");
   }
   else if (truthFunction == &truthOr)
   {
      printf("or");
   }
   else if (truthFunction == &truthXor)
   {
      printf("xor");
   }
   else if (truthFunction == &truthXorAndOrXor)
   {
      printf("xor+and|xor+or|xor+xor");
   }
   printf("\n");

   printf("keepAlive: %d\n", keepAlive);

   if (!training) printf(ANSI_CLEAR_TEXT);
 

   if (!loadFile) printf(ANSI_GRAY_TEXT);

   printf("loadFileName: \"%s\"\n", loadFileName);

   if (!loadFile) printf(ANSI_CLEAR_TEXT);


   if (!saveFile) printf(ANSI_GRAY_TEXT);

   printf("saveFileName: \"%s\"\n", saveFileName);

   if (!saveFile) printf(ANSI_CLEAR_TEXT);


   if (!readTestCases) printf(ANSI_GRAY_TEXT);

   printf("testCasesFileName: \"%s\"\n", testCasesFileName);

   if (!readTestCases) printf(ANSI_CLEAR_TEXT);
  

   if (!readTruthTable) printf(ANSI_GRAY_TEXT);

   printf("truthTableFileName: \"%s\"\n", truthTableFileName);
   
   if (!readTruthTable) printf(ANSI_CLEAR_TEXT);


   return;
} // void outputUserInput()

/**
 * Start of program execution.
 * Gets the value of config variables from user input, verifies and
 * outputs it. Then calls relevant functions in run.c, depending on 
 * whether the mode is training or not.
 */
int main(int argc, char** argv)
{
   printf(ANSI_PROJECT_COLOR "(n-layer with backpropagation)\n"
          ANSI_CLEAR_TEXT);
   if (argc > 1)
   {
      configFileName = argv[1];
   }
   printf("Registered config file is \"%s\"\n", configFileName);

   bool successful = false;

   atexit(&freeMemory);
   printf(ANSI_PROJECT_COLOR
          "----------------CCOONNFFIIGGSS-----------------\n"
          ANSI_CLEAR_TEXT);

   if (getUserInputFromFile() != -1)
   {
      snprintf(networkConfiguration, NETWORK_CONFIGURATION_LENGTH,
            "%d", lengths[0]);

      for (int it = 1; it < activationLayers; it++)
      {
         snprintf(networkConfiguration, NETWORK_CONFIGURATION_LENGTH, 
               "%s-%d", networkConfiguration, lengths[it]);
      }


      outputUserInput();
      if (validateUserInput() != -1)
      {
         printf(ANSI_PROJECT_COLOR
               "----------------SSGGIIFFNNOOCC-----------------\n"
               ANSI_CLEAR_TEXT);


         if (allocateMemory() != -1)
         {
            int result1 = 0;
            if (runningTestCases || training)
            {
               if (readTestCases)
               {
                  result1 = propagateTestCasesFromFile();
               }
               else
               {
                  result1 = propagateTestCases();
               }
            }

            if (result1 != -1)
            {
               int result2 = 0;
               if (training)
               {
                  if (readTruthTable)
                  {
                     result2 = propagateTruthTableFromFile();
                  }
                  else
                  {
                     propagateTruthTable();
                  }
               }

               if (result2 != -1)
               {
                  int result3 = 0;
                  if (randomWeightPropagation) 
                  {
                     propagateWeightsRandom();
                  }
                  else if (loadFile)
                  {
                     result3 = propagateWeightsFromFile();
                  }
                  else
                  {
                     propagateWeightsManual();
                  }


                  if (result3 != -1)
                  {
                     int nextResult = 0;
                     if (training)
                     {
                        if (callTrain() != -1)
                        {
                           callRunTestCases();
                        }
                        else
                        {
                           nextResult = -1;
                        }
                     } // if (training)
                     else if (runningTestCases) 
                     {
                        callRunTestCases();
                     }
                     else 
                     {
                        getInputValues();
                        run();
                     }

                     if (nextResult != -1)
                     {
                        if (outputNetworkInfo) 
                        {
                           printNetworkInfo();
                        }

                        if (!saveFile || saveWeights() != -1)
                        {
                           successful = true;
                        }
                     }
                  } // if (result3 != -1)
               } // if (result2 != -1)
            } // if (result1 != -1)
         } // if (allocateMemory() != -1)
      } // if (validateUserInput() != -1)
   } // if (getUserInputFromFile() != -1)
   printTimingInformation();
   printf("Execution ended %s.\n",
         successful ? "successfully" : "unsuccessfully");


   exit((int)successful);
} // int main()
